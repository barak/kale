\documentclass[11pt]{report}

% Add url support for web pages etc.
\usepackage[square, numbers]{natbib}
% For custom spacing
\usepackage{setspace}
\setstretch{1.15}
% For the \say command
\usepackage{dirtytalk}
% Figures etc.
\usepackage{graphicx}
% Draft watermark.
\usepackage{draftwatermark}
% Acronym support.
\usepackage{acro}
% Extra appendix control; Add appendices to the toc and add a blank page.
\usepackage[page, toc]{appendix}
% Figure wrapping.
\usepackage{wrapfig}
% Additional control over itemize.
\usepackage{enumitem}
% PDFs links. Must be loaded before geometry, but as late as possible.
\usepackage{hyperref}
\hypersetup{
	colorlinks,
    allcolors=blue,
}
% As required by the handbook.
\usepackage[a4paper, margin=25mm]{geometry}
% Menus and menu keys. Recommended to load late.
\usepackage[os=win]{menukeys}

\title{Kale - An attempt at an accessible and powerful visual programming
environment}
\author{Maciej Goszczycki - 16316981}
\date{}

% Acronyms must be defined before the document starts.
\DeclareAcronym{svg}{short=SVG, long=Scalable Vector Graphics}
\DeclareAcronym{ui}{short=UI, long=user interface}
\DeclareAcronym{dom}{short=DOM, long=Document Object Model}
\DeclareAcronym{jsx}{short=JSX, long=JavaScript XML}

\begin{document}

\maketitle
\tableofcontents
\clearpage

% Do not clear page after every chapter
\begingroup
\let\clearpage\relax

% *	The abstract must be an accurate reflection of what is in your report.
% * Your abstract must be self-contained, without abbreviations, footnotes, or
%   references. It should be a microcosm of the full report.
% * Your abstract must be 150-250 words written as one paragraph, and should
%   not contain displayed mathematical equations or tabular material.
% * Ensure that your abstract reads well and is grammatically correct.
% * The abstract must cover: motivation, the problem statement, the approach,
%   your results, and your conclusions.

\chapter{Abstract}
Contemporary text-based programming languages require the programer to be
constantly vigilant against syntax errors. This affects both novice and
experienced programmers. One obvious way of eliminating syntax errors is
get rid of text. While there exist many visual programming environments, many
eschew powerful editing capabilities for being beginner friendly.
This project explores how a Lisp-based visual programming environment might be
used to mitigate syntax issues while remaining attractive to both novices and
professional programmers.

\chapter{Introduction}

% Why would one care about the problem and the results? Cite appropriate
% references in this section. Explain the high-level, abstract problem that
% your project addresses. Explain what you are trying to achieve in a way that
% leads naturally into the next section.
\section{Motivation}
Syntax errors are a fact of life in the programming industry. Programmers from
novice\cite{Denny2011} to professional spend significant time fighting or
avoiding syntax errors. It is clear a visual programming environment such
%TODO: Cite scratch, cite syntax errors among professionals
Scratch could eliminate syntax errors. There exists a large body of existing
visual programming environments \cite{Beldie1983}, but most focus exclusively
on making programming accessible to children and young adults. Most
professional tools focus instead of error-detection, ignoring visual means of
editing programs as slow and cumbersome. It should be possible to create a
visual programming environment friendly to novices, but powerful enough to be
taken seriously by professionals. 


% Describe the technical problem needed to be solved in your project. Note that
% most projects solve both a more abstract, high-level problem and a specific,
% technical problem: your problem statement is the detailed technical problem
% (your motivation should cover the more abstract high-level problem). 
\section{Problem statement}
This project implements a web based visual programming environment, designed
from the ground up to fit many skill levels. Kale should demonstrate that a
drag and drop/blocks style interface can co-exist alongside a keyboard driven
professional-focused editing experience. It should generate usable code,
runnable from within the interface.

\section{Approach}

%TODO: Write these out
\begin{itemize}
	\item Implementing the rendering engine
	\item Keyboard shortcuts
	\item Drag and drop functionality
	\item Working interpreter
\end{itemize}
Lisp's highly uniform syntax, makes it the perfect 

\section{Metrics}
\section{Project}

As part of the development process I contributed patches to two different
open-source projects, including adding \texttt{\#rrggbbaa} notation support
to the Popmotion library \cite{github-pr-popmotion} and updating
\say{styled-components} TypeScript typings to the a new major 5.0
version\cite{github-pr-styled-components}.

\chapter{Technical Background}

\section{Topic material}

\subsection{Visual Programming Environments}


\subsection{Command Composition}
Composing user commands is an important concern for any code editor. Chodarev
\cite{Chodarev2016} discussed this in length, pointing out that casual
text-based editing environments rely on simple commands that operate only on
elementary objects, manipulating single character at a time. However this
approach is quite inefficient, leading leading apps to adopt a secondary set of
ad-hoc commands for performing specific combinations of operations and
high-level objects (like deleting a word). One proposed alternative are
Vim-like shortcuts, where the user combines a smaller set of motion and action
commands to work on high-level objects.

\subsection{Proportional fonts}
Studies like Campbell et al. \cite{Campbell1981} and Beldie et al.
\cite{Beldie1983} have shown that proportional (variable-pitch) fonts are
faster to read than their \texttt{monospaced} counterparts. One notable exaple
of a proportional font being used typeset code is 

\section{Technical material}

\subsection{TypeScript}
TypeScript is a structurally and gradually typed superset of JavaScript being
developed at Microsoft \cite{Typescript}. It provides stronger type-safety
guarantees than JavaScript and allows programs to use modern and experimental
JavaScript features, such as class properties or optional chaining. 


\subsection{React and related libraries}
To ease the burden of manually manipulating the \ac{dom}, Kale uses the React
\cite{React} JavaScript library. React is a self-proclaimed \say{JavaScript
library for making user interfaces} being developed by Facebook. It
allows the program to write rendering
code in a functional fashion, relying a \say{Virtual \ac{dom} to make \ac{dom}
updates efficient}. Together with \ac{jsx}, a JavaScript extension supported by
TypeScript, it makes it easy to write complex \acp{ui} for the browser.

\subsection{\acf{svg}}
\ac{svg} is a web technology which can be used to display vector images in the
browser. It is scriptable by JavaScript and styleable with CSS, making it the
perfect fit for dynamically rendering any highly custom \acp{ui}. It is used by
Scratch for rendering their blocks interface.

\chapter{The Problem}

The programming language which Kale users will be writing should map well to
the UI, but be powerful enough to be able to express complex programs. It need
not necessarily be an existing language, it fact it might not be desirable to
make it one.

A proficient user should be able to write programs and navigate Kale without
having to reach for the mouse. This might involve mapping Kale concepts to
standard shortcut keys as well as developing new ones. It should be possible
for users of existing programming environments to adjust to Kale with relative
ease. Programs written in Kale should be readable, balancing accessibility and
information density.

Novice users should be able to to construct Kale programs in a simple and
initiative manner, on every device form-factor, whether touch-screen or
mouse-driven. It should be simple for them to discover new functionality and
edit existing programs without knowledge of higher level operations.

Effectively manipulating Lisp programs often requires commands for high-level
hierarchical selections and actions, which are often difficult for users to
remember. Editors like Vim use the command composition
pattern to enable these actions, but this comes at a great cost to the learning
difficulty \cite{Chodarev2016}

\chapter{The Solution}

\section{Expression structure}

\section{Drag and drop}

One of the main changes Kale introduces compared to a normal Lisp editor is
drag and drop. It lets novice users effectively manipulate Kale programs,
without prior knowledge of commands like copy and paste. Kale distinguished
between two types of drag and drop: Replacement and Insertion. 

\section{Layout}

One of the key ideas in Kale is that of structural underlines. As a
fundamental unit of nesting, parentheses present a number of challenges to a
user using drag and drop.
%TODO Talk about in inline, non-inline, underlines optional bubbles.

\section{Command structure}

Because Kale does not operate on elementary text elements, even the most
basic
commands can be much higher-level than ordinary editors, since instead of a
current cursor position, Kale operates on the selected expression. Even so,
figuring out the correct set of commands proved to be a challenge.

\newcommand{\ak}[1]{\keys{\arrowkey{#1}}}
A good example of the difficulties that arise are the arrow key commands
\ak{^} \ak{v} \ak{<} \ak{>}. Initially these were implemented as
fundamental tree operations: \say{Select parent}, \say{Select first child},
\say{Select left sibling}, and \say{Select right sibling} respectively.
While logical, these operations were unintuitive to every user
Kale was shown too, including the author. In the end \say{smart selection} was
implemented, where \ak{<} and \ak{>} use the pre-order

\footnote{The preorder traversal algorithm traverses the parent node first,
then traverses the left and right tree by calling the itself on each.}

traversal, while \ak{^} and \ak{v}
pre-order traverse only non-inline non-list expressions, mirroring the visual
line motion a normal cursor might make.

\section{Discoverability}
\setlength\intextsep{0pt}
\begin{wrapfigure}[21]{R}{5.5cm}
\includegraphics[width=5.5cm]{figures/menu.png}
\caption{Kale's Context Menu}
\end{wrapfigure}
Most commands can be accessed in at least three ways, through their dedicated
keyboard shortcut, the context menu and the top-level editor menu. In case the
user is keen on using the keyboard shortcuts but forgot a specific command,
each editor menu-item shows the corresponding keyboard shortcut, and each
shortcut can be triggered whilst the context menu is open. These keyboard
shortcut indicators are also placed throughout Kale to help with discovering
shortcuts for the Clipboard List or the Function Search menu.


\section{High-level manipulation}



\subsection{Clipboard list}
\begin{wrapfigure}[11]{R}{0.pt}
	\includegraphics[width=5.5cm]{figures/clipboard}
	\caption{The Clipboard List}
\end{wrapfigure}

Relinquishing control over the elementary elements of a program might
potentially make more high-level manipulation problematic. To remedy this
Kale needed to provide a better way of transforming expressions. Andrew Blinn's
Fructure \cite{Fructure} environment tackles this by letting user colour
expressions, then
using a special transformation mode where the user can enter new expression or
use one of the previously coloured ones. While imbued with a certain sense of
mathematical purity, this approach deals poorly with more complex refactorings
and requires colour vision.

Kale's solution to this comes in the form of the \textbf{Clipboard List}. The
Clipboard List is a stack of expressions, shown on the right-hand side of the
screen. Kale provides a \say{Copy} \keys{C} command, which copies the currently
selected expression to the top of the stack. To facilitate more destructive
refactoring, Kale provides a palette of deletion commands:

\begin{itemize}[noitemsep]
	\item \say{Delete} \keys{\backspace}
	\item \say{Cut} \keys{X}
		\footnote{Based on the common \keys{\ctrl + X} shortcut}
	\item \say{Delete and Add Space} \keys{R}
		%TODO: Which appendix.
		\footnote{See Appendix for detailed origins of the shortcuts}
	\item \say{Cut and Add Space} \keys{S}
\end{itemize}

\subsection{Smart space}
%TODO: Show a sequence explaining how this works.
%TODO: Mention how this isn't a problem in scratch since you can't add new
% arguments.
In contemporary programming environments various punctuation marks are used to
create new expressions. This presents a challenge for an editor like Kale, how
to create new expressions. At first this was implemented as a set of
expression kind specific operations like \say{Create new child}, \say{Create
new sibling}, and \say{Create new line}. However this proved unintuitive as
unlike classical punctuation, the keys for these operations did not correspond
to any character on the screen, thus making it hard to memorise the shortcuts.

The solution Kale is using is named \textbf{Smart Space}. Smart space is a
high-level operation that attempts to perform a reasonable action no matter the
selection.
\begin{itemize}[noitemsep]
	\item If a function is selected, create a new child space in the first
argument.
	\item If a space is selected, use the \say{Move Up} \keys{\shift + P}
operation.
	\item Otherwise create a new sibling space to the right of the selection, for
example creating a new argument.
\end{itemize}

Note that this does not cover \say{Crete new line} operation, so this option is
still exists as
\say{New Line Below} \keys{N} / \say{New Line Below} \keys{\shift + N}.

\begin{figure}
	\begin{minipage}{0.5\linewidth}
	\centering
	\includegraphics[width=\linewidth]{figures/clipboard.png}
	\caption{First.}
	\end{minipage}
	\qquad
	\begin{minipage}{0.5\linewidth}
	\centering
	\includegraphics[width=\linewidth]{figures/clipboard.png}
	\caption{First.}
	\end{minipage}
\end{figure}

\section{Novice Users}
A very powerful operation for manipulating programs is drag and drop. It allows
for direct manipulation of Kale expressions, without requiring any knowledge of
the keybindings.

\section{Professional users}

%TODO: Talk about the different expr types

High level operations and complex programs necessitate an intelligent layout
engine which is able to cleanly layout arbitrary code.
%TODO: Write a quick slurp program

The conditions for an inline expressions are as follows:

\begin{itemize}[noitemsep]
	\item Expression is a literal\footnote{In the future this might not be the
only condition as more literal types get added}
	\item Expression is a variable name
	\item Expression is a call with no arguments
	\item Expression is a call and the following are true
	\begin{enumerate}[noitemsep]
		\item Every argument is also inline
		\item The sum total length of the arguments is below 300 pixels
		\item The hight of the expression tree of every argument is below 4
	\end{enumerate}
\end{itemize}

\section{Font choice}

\chapter{Implementation}

\chapter{Evaluation}

Kale good, text editing bad.

\chapter{Conclusion}

\section{Feasibility of visual programming environments}

\section{Future Work}

\begin{itemize}
	\item 
\end{itemize}

\endgroup % Ends the clearpage re-definition group
\clearpage
\renewcommand*{\bibfont}{\raggedright} % Make the reference ragged right.
\bibliographystyle{unsrtnat} % List in order of mention.
\bibliography{bibliography.bib}

\begin{appendices}
\chapter{Kale commands}
\newcommand{\shortcut}[2]{\section[#1]{#1 \hfill #2}}

Note that usefully a command and it's shifted \keys{\shift} variety are closely
related.

\shortcut{Add Space or Move Space Up}{\keys{\SPACE}}
Add Space or Move Space Up

\shortcut{Copy}{\keys{C}}
Copy

\shortcut{Select Parent}{\keys{P}}
Select Parent

\shortcut{Move Up}{\keys{\shift + P}}
Move Up

\shortcut{New Line Above / Below}{\keys{N} / \keys{\shift + N}}
New Line Above / Below

\shortcut{Delete}{\keys{\backspace}}
Delete

\shortcut{Cut}{\keys{X}}
Cut

\shortcut{Delete and Add Space}{\keys{R}}
Delete and Add Space

\shortcut{Cut and Add Space}{\keys{S}}
Cut and Add Space


\end{appendices}

\end{document}
